package AleksandrVasko.Collections.СomparatorCompareTo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * The type Card.
 */
/* Интерфейс Comparable<T> накладывает общий порядок на объекты каждого класса, который его реализует.
 Это упорядочение называется естественным упорядочением класса, а метод сравнения класса называется его естественным методом сравнения.
Списки (и массивы) объектов, реализующих этот интерфейс, могут быть автоматически отсортированы по Collections.sort (и Arrays.sort).
Объекты, реализующие этот интерфейс, могут использоваться в качестве ключей на отсортированной карте или в качестве
элементов в отсортированном наборе без необходимости указывать компаратор. Считается, что естественный порядок для
класса C согласуется с equals тогда и только тогда, когда e1.compareTo(e2) == 0 имеет то же логическое значение,
что и e1.equals(e2) для каждого e1 и e2 класса C. Обратите внимание, что null не является экземпляром какого-либо класса,
и e.compareTo(null) должно вызывать исключение NullPointerException,даже если e.equals(null) возвращает false.
Настоятельно рекомендуется (хотя и не обязательно), чтобы естественные порядки соответствовали равным.
Это происходит потому, что упорядоченные наборы (и упорядоченные карты)без явных компараторов ведут себя "странно",
когда они используются с элементами (или ключами), естественный порядок которых не соответствует равенствам.
В частности, такой отсортированный набор (или отсортированная карта)нарушает общий контракт на набор (или карту),
который определен в терминах метода equals.Например, если добавить два ключа a и b таким образом,
что (!a.equals(b) && a.compareTo(b) == 0) к отсортированному набору,в котором не используется явный компаратор,
вторая операция добавления возвращает значение false (и размер отсортированного набора не увеличивается),
потому что a и b эквивалентны с точки зрения отсортированного набора.Практически все основные классы Java,
реализующие Comparable, имеют естественные порядки, соответствующие equals. Одним исключением является java.math.BigDecimal,
естественный порядок которого приравнивает объекты BigDecimal с одинаковыми значениями и разной точностью (например, 4.0 и 4.00).
*/
public class Card implements Comparable<Card> {
    /*Класс Card имплементирует интерфейс Comparable с типом <Card>,
    в нем перезаписан метод compareTo, поэтому его объекты могут быть отсортированы в списках. */
    private final Mast mast;
    private final Name name;

    /**
     * Instantiates a new Card.
     *
     * @param mast the mast
     * @param name the name
     */
    public Card(Mast mast, Name name) {
        this.mast = mast;
        this.name = name;
    }

    /**
     * Gets mast.
     *
     * @return the mast
     */
    public Mast getMast() {
        return mast;
    }

    /**
     * Gets name.
     *
     * @return the name
     */
    public Name getName() {
        return name;
    }

    /* Сравнивает этот объект с указанным объектом для заказа.
         Возвращает отрицательное целое число, ноль или положительное целое число,
         поскольку этот объект меньше, равен или больше указанного объекта.*/
    @Override
    public int compareTo(Card card) {                    // в параметры передается объект того же типа что и у объекта у которого вызывается метод.
        Name[] values = Name.values();                   //для сравнения будем использовать индексы очередности списка,
                                                         // поэтому очередность записи объектов в enum Name и есть условие старшинства объектов. Метод values() возвращает массив из enum.
        List<Name> listName = Arrays.asList(values);     //С помощью метода asList() преобразуем массив в коллекцию список.


        if (listName.indexOf(this.name) < listName.indexOf(card.getName())) {           // Сравниваем индекс поля name в списке listName , у текущего объекта,
                                                                                        // c помощью this  и индекс у name переданного в параметрах метода.
            return -1;                                                                  // Если результат -1  текущий объект меньше.
        } else if (listName.indexOf(this.name) > listName.indexOf(card.getName())) {
            return +1;                                                                  // +1  текущий объект больше.
        } else if (listName.indexOf(this.name) == listName.indexOf(card.getName())) {
            return String.valueOf(this.mast).compareTo(String.valueOf(card.getMast())); // Если объекты равны то с помощью метода valueOf,
                                                                                        //  у поля mast текущего объекта (возвращает строковое представление объекта),
                                                                                        // сравниваем с полем mast у объекта переданного в параметрах,  с помощью метода compareTo.
        }
        return 0; // возвращаем 0 если сравниваемые объекты равны и по полю name и по полю mast.
    }

    @Override
    public String toString() {
        return "Card " + mast + " " + name;

    }

    /**
     * Print card.
     *
     * @param al the al
     */
    public static void printCard(ArrayList<Card> al) {
        System.out.println("-------------------------------------------------");
        int i = 0;
        for (Card s : al) {
            i++;
            System.out.printf("%-30s %s", s.toString(), i % 4 == 0 ? "\n" : " ");
        }
    }
}
