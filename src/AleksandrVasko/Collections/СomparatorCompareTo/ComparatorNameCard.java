package AleksandrVasko.Collections.СomparatorCompareTo;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
/*Функция сравнения, которая налагает общий порядок на некоторую коллекцию объектов. Компараторы могут быть переданы в
метод сортировки (например, коллекции.сортировка или массивы.сортировка), чтобы обеспечить точный контроль над порядком
сортировки. Компараторы также могут использоваться для управления порядком определенных структур данных
(например, отсортированных наборов или отсортированных карт) или для обеспечения упорядочения коллекций объектов,
которые не имеют естественного порядка.Порядок, налагаемый компаратором c на набор элементов S, считается
согласованным с равными тогда и только тогда, когда c.сравнение(e1, e2)==0 имеет то же логическое значение,
что и e1.равно(e2) для каждого e1 и e2 в S. Следует проявлять осторожность при использовании компаратора,
способного налагать порядок, несовместимый с равными, для упорядочения отсортированного набора (или отсортированной карты).
Предположим, что сортированный набор (или отсортированная карта) с явным компаратором c используется с элементами (или ключами),
взятыми из набора S. Если порядок, наложенный c на S, не соответствует равным, отсортированное множество
(или отсортированная карта) будет вести себя "странно"." В частности, отсортированное множество (или отсортированная карта)
нарушит общий контракт на набор (или карту), который определен в терминах равных. Например, предположим,
что один добавляет два элемента a и b таким образом, что (a.равно(b) && c.сравните(a, b) != 0) с пустым набором деревьев с помощью компаратора c.
 Вторая операция добавления вернет значение true (и размер набора деревьев увеличится),
 потому что a и b не эквивалентны с точки зрения набора деревьев, даже если это противоречит спецификации метода Set.add.
Примечание: Обычно компараторам рекомендуется также реализовывать java.io.Serializable, поскольку они могут использоваться
 в качестве методов упорядочения в сериализуемых структурах данных (таких как набор деревьев, карта деревьев).
 Для успешной сериализации структуры данных компаратор (если он предусмотрен) должен реализовать сериализуемую.
*/
public class ComparatorNameCard implements Comparator<Card> {
    List<Name> listName = Arrays.asList(Name.values());

    @Override
    public int compare(Card card1, Card card2) {
        if (listName.indexOf(card1.getName()) < listName.indexOf(card2.getName())) {
            return -1;
        } else if (listName.indexOf(card1.getName()) > listName.indexOf(card2.getName())) {
            return +1;
        }


        return 0;
    }
}
