package AleksandrVasko.Collections.QueueDeque;

import java.util.PriorityQueue;
import java.util.Queue;
/*Неограниченная очередь приоритетов, основанная на куче приоритетов.
Элементы приоритетной очереди упорядочиваются в соответствии с их естественным порядком или с помощью компаратора,
предоставляемого во время построения очереди, в зависимости от используемого конструктора.
Приоритетная очередь не допускает нулевые элементы. Приоритетная очередь, основанная на естественном порядке,
 также не позволяет вставлять несопоставимые объекты (это может привести к исключению ClassCastException).
Глава этой очереди является наименьшим элементом по отношению к указанному порядку.
Если несколько элементов связаны по наименьшей стоимости, голова является одним из этих элементов-связи разрываются произвольно.
Операции извлечения очереди опрашивают, удаляют, просматривают и получают доступ к элементу в начале очереди.
Приоритетная очередь не ограничена, но имеет внутреннюю емкость, определяющую размер массива, используемого для хранения элементов в очереди.
Он всегда по крайней мере равен размеру очереди. По мере добавления элементов в приоритетную очередь ее емкость автоматически увеличивается.
Детали политики роста не уточняются.Этот класс и его итератор реализуют все дополнительные методы интерфейсов Коллекции и итератора.
Итератор, указанный в методе iterator (), и разделитель, указанный в методе spliterator (), не гарантируют,
что элементы приоритетной очереди будут проходить в каком-либо определенном порядке. Если вам нужен упорядоченный обход,
рассмотрите возможность использования Arrays.sort(pq.toArray()).Обратите внимание, что эта реализация не синхронизирована.
Несколько потоков не должны одновременно обращаться к экземпляру PriorityQueue, если какой-либо из потоков изменяет очередь.
Вместо этого используйте потокобезопасный java.util.concurrent.Приоритет блокирующего класса очереди.
Примечание к реализации: эта реализация обеспечивает O(log(n)) время для методов постановки в очередь и удаления из очереди
(предложение, опрос, удаление() и добавление); линейное время для методов удаления(объекта) и содержит(Объект);
и постоянное время для методов извлечения (просмотр, элемент и размер).*/

public class QueuePriorityQueue {
    public static void main(String[] args) {
        Queue<Integer> list = new PriorityQueue<>();
        list.offer(1);/*помещает указанный элемент в эту очередь, если это возможно сделать немедленно, не нарушая ограничений емкости.
                            При использовании очереди с ограниченной емкостью этот метод, как правило, предпочтительнее для добавления,
                            который может не вставить элемент, только вызвав исключение. */
        list.offer(2);
        list.offer(3);
        list.offer(4);
        System.out.println(list);
        list.add(5);
        System.out.println(list);
        System.out.println( list.peek());//Извлекает, но не удаляет заголовок этой очереди или возвращает значение null, если эта очередь пуста.
        list.poll();//Извлекает и удаляет заголовок этой очереди или возвращает значение null, если эта очередь пуста.
        System.out.println(list);
        list.element();//Извлекает, но не удаляет главу этой очереди. Этот метод отличается от peek только тем, что он создает исключение, если эта очередь пуста.
        list.remove();// Извлекает и удаляет заголовок этой очереди. Этот метод отличается от poll() только тем, что он создает исключение, если эта очередь пуста.

    }
}
