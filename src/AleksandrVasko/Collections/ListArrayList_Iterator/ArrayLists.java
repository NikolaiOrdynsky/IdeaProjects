package AleksandrVasko.Collections.ListArrayList_Iterator;

import java.util.*;
/*Изменяемый размер-реализация массива интерфейса List. Реализует все необязательные операции со списком и
разрешает все элементы, включая null. В дополнение к реализации интерфейса списка этот класс предоставляет
методы для управления размером массива, который используется внутри для хранения списка. (Этот класс примерно
 эквивалентен Vector, за исключением того, что он несинхронизирован.)
Операции size, isEmpty, get, set, итератор и листератор выполняются в постоянное время.
Операция добавления выполняется в амортизированное постоянное время, то есть для добавления n элементов требуется
 O(n) времени. Все остальные операции выполняются в линейное время (грубо говоря). Коэффициент константы невелик
 по сравнению с коэффициентом для реализации LinkedList.
Каждый экземпляр ArrayList имеет определенную емкость. Емкость-это размер массива, используемого для хранения
элементов в списке. Он всегда по крайней мере равен размеру списка. По мере добавления элементов в список массивов
его емкость автоматически увеличивается. Детали политики роста не уточняются, кроме того факта, что добавление
элемента имеет постоянные амортизированные временные затраты.
Приложение может увеличить емкость экземпляра ArrayList перед добавлением большого количества элементов с помощью
операции ensureCapacity. Это может уменьшить объем дополнительного перераспределения.
Обратите внимание, что эта реализация не синхронизирована. Если несколько потоков одновременно обращаются к экземпляру
 ArrayList и по крайней мере один из потоков изменяет структуру списка, он должен быть синхронизирован извне.
 (Структурная модификация-это любая операция, которая добавляет или удаляет один или несколько элементов или явно
 изменяет размер резервного массива; простая установка значения элемента не является структурной модификацией.)
 Обычно это достигается путем синхронизации с каким-либо объектом, который естественным образом инкапсулирует список.
 Если такого объекта не существует, список следует "завернуть" с помощью коллекций.Метод синхронизированного списка.
 Это лучше всего делать во время создания, чтобы предотвратить случайный несинхронизированный доступ к списку:
     Список список = Коллекции.Синхронизированный список(новый список массивов(...));
Итераторы, возвращаемые методами iterator и ListIterator этого класса, работают быстро: если список структурно
изменен в любое время после создания итератора любым способом, кроме как с помощью собственных методов удаления
или добавления итератора, итератор создаст исключение ConcurrentModificationException.
Таким образом, перед лицом одновременной модификации итератор выходит из строя быстро и чисто, вместо того,
чтобы рисковать произвольным, недетерминированным поведением в неопределенное время в будущем.
*/
public class ArrayLists {
    private List<String> listTask = new ArrayList<>();

    // Добавить строку в конец коллекции List.
    public void addInList(String task) {
        listTask.add(task);
    }

    //Добавить строку в определенную позицию колеекции List.
    public void addInIndexList(int index, String task) {
        listTask.add(index, task);
    }

    // Получить индекс порядковой позиции строки в коллекции.
    public int seurchIndexList(String task) {
        return listTask.indexOf(task);
    }

    //Изменить строку  в коллекции, в позиции index.
    public void setList(int index, String task) {
        listTask.set(index, task);
    }

    //Удалить строку из коллекции.
    public void removeList(int index) {
        listTask.remove(index);
    }

    //Показать элементы коллекции.
    public void printList() {
//        for (int i = 0; i < listTask.size(); i++) {
//            System.out.println(i+"["+listTask.get(i)+"]");
      //  Collections.sort(listTask);
        Iterator<String> iterator = listTask.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }

    public boolean addSortAlfavit(String task) {
        ListIterator<String> listIterator = listTask.listIterator();            //listiterator помещается в переменную
        while (listIterator.hasNext()) {                                        // цикл выполняется пока условие "следующий элемент есть в списке" возвращает true.
            int index = listIterator.next().compareTo(task);                    // В переменную index помещается результат сравнения следующего элемента с элемнтом из параметра метода
            if (index == 0) {                                                   //если результат сравнения равен 0 , значит сравнивыемые элементы равны
                System.out.println("Такой элемента уже есть в коллекции.");
                return true;                                                    // закончить цикл
            } else if (index > 0) {                                             // если в переменной index число 1 то это значит выбранный элемент для сравнения больше чем элемнт из параметра метода
                listIterator.previous();                                        // вернуть предыдущий элемент и переместить курсор
                listIterator.add(task);                                         // добавить элемент на место курсра
                return true;                                                    // закончить цикл
            }
        }
        listTask.add(task);
        return true;
    }

    public int sizeList() {

        return listTask.size();
    }
}
