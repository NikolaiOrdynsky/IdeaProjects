package AleksandrVasko.Collections.SetCollection;

import java.util.Arrays;

import java.util.NavigableSet;
import java.util.Set;
import java.util.TreeSet;
/*Реализация навигационного набора, основанная на карте деревьев. Элементы упорядочиваются с использованием их естественного порядка или с помощью компаратора,
предоставляемого во время создания набора, в зависимости от используемого конструктора.
Эта реализация обеспечивает гарантированную стоимость времени регистрации(n) для основных операций (добавление, удаление и содержит).
Обратите внимание, что порядок, поддерживаемый набором (независимо от того, предусмотрен ли явный компаратор или нет),
должен соответствовать equals, чтобы правильно реализовать интерфейс набора. (См. Сопоставимый или Компаратор для точного определения соответствия равным.)
Это происходит потому, что интерфейс набора определен в терминах операции "равно",
но экземпляр набора деревьев выполняет все сравнения элементов с помощью метода compareTo (или сравнения),
поэтому два элемента, которые считаются равными с помощью этого метода, с точки зрения набора равны.
Поведение набора четко определено, даже если его порядок не соответствует равным; он просто не подчиняется общему контракту интерфейса набора.
Обратите внимание, что эта реализация не синхронизирована. Если несколько потоков одновременно обращаются к набору дерева и по крайней мере один из потоков изменяет набор,
он должен быть синхронизирован извне. Обычно это достигается путем синхронизации с каким-либо объектом, который естественным образом инкапсулирует набор.
Если такого объекта не существует, набор должен быть "завернут" с помощью коллекций.Метод synchronizedSortedSet.
Это лучше всего делать во время создания, чтобы предотвратить случайный несинхронизированный доступ к набору.
     */
public class SetTreeSet {
    public static void main(String[] args) {
        NavigableSet <Car> listCar = new TreeSet<>();
        listCar.add(new Car("vw", "golf", 3000));
        listCar.add(new Car("vw", "jetta", 3100));
        listCar.add(new Car("audi", "a4", 4000));
        listCar.add(new Car("audi", "tt", 5000));
        listCar.add(new Car("mersedes", "e500", 6000));
        listCar.add(new Car("ferrari", "cfd", 10000));
        Car.print(listCar);

        System.out.println(listCar.ceiling(new Car("audi", "a4", 4100)));//Возвращает наименьший элемент в этом наборе, строго больший, чем данный элемент, или значение null, если такого элемента нет.
        System.out.println(listCar.floor(new Car("audi", "a4", 4100)));//Возвращает наибольший элемент в этом наборе, строго меньший, чем данный элемент, или равный нулю, если такого элемента нет.
        System.out.println(listCar.higher(new Car("audi", "a4", 4000)));//Возвращает слудущющий элемент по возростанию, или равный нулю, если такого элемента нет
        System.out.println(listCar.lower(new Car("audi", "a4", 4000)));//Возвращает предыдущий элемент по убыванию, или равный нулю, если такого элемента нет.
    }
}